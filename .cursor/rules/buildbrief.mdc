---
description: Three.js simulation and architecture - 3D lunar nodes web app
globs:
  - src/**/*.ts
  - src/**/*.tsx
  - public/index.html
alwaysApply: true
---

# Build brief: interactive 3D lunar nodes web app (Three.js)

Treat all items as requirements.

## Goal
Create a shareable, mobile-friendly, GPU-accelerated web app that shows a symbolic 3D model of Earth at the center, the ecliptic plane, the Moon's orbital plane, and the lunar nodes at their intersection. Keep geometry simple. Keep relative motion speeds accurate. Provide an adjustable playback speed.

## Tech stack
- Languages: TypeScript, HTML, CSS
- 3D engine: Three.js
- Controls: `OrbitControls` from `three/examples/jsm/controls/OrbitControls.js`
- Labels: `CSS2DRenderer` from `three/examples/jsm/renderers/CSS2DRenderer.js`
- Dev-only control panel: `lil-gui` or dat.GUI (do not ship it by default)
- Build tool: Vite
- Lint and format: ESLint and Prettier

## Install
Add these to `package.json`:
```json
{
  "dependencies": {
    "three": "^0.168.0",
    "lil-gui": "^0.19.2"
  },
  "devDependencies": {
    "vite": "^5.2.0",
    "typescript": "^5.4.0",
    "@types/three": "^0.168.0"
  }
}

Project structure

/public
  index.html
/src
  main.ts
  scene/
    initScene.ts
    camera.ts
    lights.ts
    earth.ts
    planes.ts
    moon.ts
    nodes.ts
    labels.ts
    starfield.ts
  ui/
    controls.ts         // lil-gui setup and bindings (dev only)
    state.ts            // reactive app state (time, speed, inclination, toggles)
  utils/
    math.ts             // vectors, quaternions, plane intersection helpers
    constants.ts        // orbital periods, tilt defaults
styles.css
vite.config.ts

Visual requirements
	•	Earth at the origin as a low-poly sphere.
	•	Ecliptic plane: large translucent ring or disk aligned to world XZ.
	•	Lunar plane: same geometry, tilted by an adjustable inclination.
	•	Nodes: show the intersection line of the two planes, and mark the two opposite points as North Node and South Node.
	•	Canvas background is a black starfield.

Physics and timing

Symbolic, not to scale, but keep relative speeds realistic:
	•	Sidereal year days: 365.25
	•	Sidereal lunar period days: 27.321661
	•	Relative angular speed ratio Moon to Sun: 365.25 / 27.321661
	•	Default lunar inclination degrees: 5.145

All angular math is in radians internally. Expose degrees in UI.

Create src/utils/constants.ts:

export const SIDEREAL_YEAR_DAYS = 365.25;
export const SIDEREAL_MONTH_DAYS = 27.321661;
export const DEFAULT_INCLINATION_DEG = 5.145;
export const TWO_PI = Math.PI * 2;
export const MOON_TO_SUN_RATE = SIDEREAL_YEAR_DAYS / SIDEREAL_MONTH_DAYS;

Starfield helper

Create src/scene/starfield.ts:

import * as THREE from "three";

export function makeStarfield(count = 4000, radius = 1200) {
  const geo = new THREE.BufferGeometry();
  const pos = new Float32Array(count * 3);
  for (let i = 0; i < count; i++) {
    const r = radius * (0.6 + Math.random() * 0.4);
    const th = Math.random() * Math.PI * 2;
    const ph = Math.acos(2 * Math.random() - 1);
    pos[i * 3 + 0] = r * Math.sin(ph) * Math.cos(th);
    pos[i * 3 + 1] = r * Math.sin(ph) * Math.sin(th);
    pos[i * 3 + 2] = r * Math.cos(ph);
  }
  geo.setAttribute("position", new THREE.BufferAttribute(pos, 3));
  const mat = new THREE.PointsMaterial({ size: 1.2, sizeAttenuation: true, color: 0xffffff });
  const pts = new THREE.Points(geo, mat);
  pts.frustumCulled = false;
  return pts;
}

Interaction requirements
	•	Use OrbitControls for camera rotation and zoom. Enable damping. Target is Earth’s center.
	•	Provide controls:
	•	inclinationDeg range 0..10
	•	speedMultiplier options 0, 0.25, 1, 5, 20, 100
	•	timeScrub 0..1 mapping to a full lunar cycle
	•	Toggles: show ecliptic, show lunar plane, show labels, show trails
	•	Touch friendly. Ensure controls are usable on mobile.

Labels
	•	Use CSS2DRenderer for HTML labels that track points. Labels: North Node, South Node, plane names.

Implementation steps
	1.	Scene init
Create a WebGLRenderer with antialiasing on desktop. Cap pixel ratio with Math.min(window.devicePixelRatio, 2). Call setSize and update on resize. Set clear color to black. Add the starfield.
	2.	Camera and controls
Use a PerspectiveCamera with a sensible FOV, near 0.1, far large enough for rings. Attach OrbitControls and enable damping.
	3.	Lighting
AmbientLight plus one DirectionalLight. Avoid heavy shadows.
	4.	Earth
Create a SphereGeometry with a standard material. Optional texture later.
	5.	Planes
Ecliptic plane: CircleGeometry or RingGeometry with transparent material, aligned to XZ.
Lunar plane: identical geometry inside a parent Group. Rotate the group by inclinationDeg around the world X axis. Apply rotations via quaternions to avoid gimbal issues.
	6.	Nodes line and markers

	•	Ecliptic normal is world +Y. Lunar normal is +Y rotated by inclinationDeg around X.
	•	Intersection direction = normalize(cross(eclipticNormal, lunarNormal)).
	•	Draw a long thin line through the origin along that direction.
	•	Place two small markers at opposite ends. Label them North Node and South Node.

	7.	Moon orbit and motion

	•	Use a moonOrbitGroup that rotates around world Y for lunar longitude.
	•	Inside it, use a lunarTiltGroup that applies inclination to the orbit path.
	•	Place the Moon mesh at a fixed radius on the tilted orbit.
	•	Per frame: t += deltaSeconds * speedMultiplier.
	•	thetaMoon = t * (TWO_PI / SIDEREAL_MONTH_DAYS)
	•	Optionally add a symbolic Sun with thetaSun = t * (TWO_PI / SIDEREAL_YEAR_DAYS) for ratio correctness.

	8.	UI binding

	•	Maintain a small reactive state object: time, isPlaying, speedMultiplier, inclinationDeg, showEcliptic, showLunarPlane, showLabels.
	•	In dev, expose these via lil-gui. For production, use simple HTML controls bound to state.
	•	On inclinationDeg change, rotate only the lunar plane parent group.
	•	On timeScrub, pause playback and set the Moon angle from the scrub value.

	9.	Labels

	•	Compute world positions for nodes at a fixed radius along the intersection direction and its opposite.
	•	Attach CSS2DObject labels to invisible Object3Ds at those positions.

	10.	Animation loop

	•	Use requestAnimationFrame. Compute deltaSeconds with a clock.
	•	If playing, advance state.time. Update Moon angle.
	•	Update controls damping. Render the WebGL scene, then render CSS2D labels.

	11.	Responsiveness and performance

	•	Handle resize to update camera aspect and renderer sizes.
	•	Cap pixel ratio. Reduce segment counts on small screens.
	•	Keep materials basic. No postprocessing.

	12.	Accessibility

	•	Provide keyboard toggles for play or pause and stepping time.
	•	Provide a text panel that explains what the user is seeing.

	13.	Testing

	•	Verify on Chrome, Safari, Firefox, Android and iOS browsers.
	•	Confirm that sliders change only the intended axis or parameter.

Deliverables
	•	A Vite project that builds to static files.
	•	Source organized per the structure above.
	•	README with instructions for npm run dev and npm run build.

